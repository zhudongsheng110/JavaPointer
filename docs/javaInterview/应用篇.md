> 十、**应用篇**
- [通过redis实现用户购物车](#通过redis实现用户购物车)
- [支付功能实现](#支付功能实现)
- [redis实现抢购秒杀功能](#redis实现抢购秒杀功能)
- [分布式](#分布式)
    - [说一说你对分布式的理解：](#说一说你对分布式的理解)
- [dubbo架构：](#dubbo架构)
    - [dubbo的网关：](#dubbo的网关)
_____
### 通过redis实现用户购物车
    我们要做的是将购物车商品信息存储到redis cluster集群中
    1.通过token从redis cluster集群中取到用户的id
    细节：从cookie中取到token，然后拼串：”login:”+token，以此串为键，从redis cluster中取到字段为”id”的值userId
    2.拼串：”shopping:”+userId，以此串为键，将商品id和商品数量信息存储到redis cluster集群
    细节：可以先通过”shopping:”+userId从redis cluster集群中取一下购物车信息，如果没有商品，那就直接添加进去就行了；如果有商品，那就需要判断是不是存在和所选商品一样的商品，如果存在，就在原来的基础上让商品数量加1即可，如果不存在，则直接添加进去
    cookie存储游客购物车，如果cookie被禁用，使用js的sessionStorage 来存储购物车信息
    sessionStorage 是HTML5新增的一个会话存储对象，用于临时保存同一窗口(或标签页)的数据，在关闭窗口或标签页之后将会删除这些数据。
    游客购物车我们是通过cookie来存放商品信息的，当游客选择好商品，点击加入购物车之后，会将商品id传到后台controller，这个时候我们可以先获取到用户请求携带的cookie，然后找一下有没有以这个购物车命名的那个cookie，如果没有的话，我们就先通过传过来的商品id去查商品信息，把结果放在list集合里面，然后通过fastJson的jar包把list转换成json类型，这个时候用的是JSON.toJSONString(list)的方法，然后对这个json进行utf-8编码(URLEncoder.encode(json,"utf-8"))，存到cookie中去；
    如果之前就已经存过cookie的话，我们是先将那个cookie取出，这个时候的值是json类型，我们需要先对这个json进行解码(URLDecoder.decode(json,"utf-8"))，然后通过fastJson的jar包把json转换成list类型，这个时候用的是JSON.parseArray(json,ItemsVo.class)方法，然后遍历这个list，判断一下传过来的商品id和list里面商品的id有没有一致的，如果有的话就把list里面的商品那个对象的数量属性+1，如果没有，就去数据库里面把该商品查出来，然后放到list集合里面就可以了，最后再把list转换成json类型，编码存到cookie里面就可以了
    那么如果要向删除游客购物车里面的商品该怎么做呢？
    当用户点击删除的时候，通过ajax异步请求将所要删除的商品的id传到后台删除的controller
    中，首先要取到cookie信息，找出cookie里面所存放的购物车商品信息，这个商品信息是以json类型进行存储的，我们需要将这个json解码并转换成list集合，然后通过Iterator迭代器遍历这个list，找出要删除的那些商品，通过remove方法，将其移除掉，最后得到的那个list就是删除之后的，然后将这个list再次转换成json类型，编码并存到cookie中，最后返回一条信息给ajax的回调函数，让其刷新一下页面
    游客购物车和用户购物车合并当用户以游客的身份将商品加入购物车，然后登录之后，我们需要将游客的购物车中的商品合并到用户的购物车里面，这个时候我们需要获取到两种信息，一种是cookie里面的商品信息，另一种是用户购物车里面的商品信息，cookie里面的商品信息我们可以通过cookie来获取到，接下来是获取用户购物车信息，用户的购物车信息我们是通过以用户的id为键，以商品id和购买数量组成的map集合为值，存储到redis cluster集群里面的，存储的类型是hash类型，所以我们要先获取到用户的id，通过cookie携带的token令牌，从redis cluster集群中获取到用户id，然后在通过用户id获取到他的购物车信息，这个是map类型的，键是商品id，值是商品数量；
    获取到这两种信息之后，我们就能将其进行合并，首先将cookie里面的购物车信息转换成list，用户的购物车map类型通过keySet()方法，把商品id存在set集合里面，然后通过双重循环，外层是list遍历，内层将set集合通过Iterator进行遍历，找到有没有相同的id，如果有的话，就通过jedisCluster将集群中对应商品id的数量+cookie中对应商品id的数量即可，如果没有就将cookie中的商品id和数量通过jedisCluster的hset方法添加到集群中
### 支付功能实现
    当用户点击购买之后，会进入订单详情页面，在这个订单详情页面中，需要设置收货人的相关信息，比如收货人姓名、收获地址、联系方式等；还要显示订单的相关信息，包括订单号、订单总金额、商品详情以及对应的价格和数量；然后选择支付方式(微信或支付宝)，还有付款按钮；
    比如说用户选了支付宝支付,点击了付款,请求进入后台之后，我们需要调用支付宝提供的接口，支付宝这个接口api要求传一些参数，比如: 付款金额，订单标题，订单介绍，外部订单号(一个唯一的订单号，用于调用支付宝其他接口进行查询交易，退款..) ，支付宝方会创建预交易记录，我们判断支付宝回应的状态码，成功的话呢，就可以获取到支付二维码图片信息(非必需) 根据我们经理的要求呢，需要将我们网站的logo的绘制到二维码中间，所以我就将收到的二维码用第三方jar工具处理过后，才将其返回给前台，前台收到二维码之后呢，显示到页面,会用js脚本每隔2秒请求后台查询订单是否已经完成支付，后台的查询是携带着订单号去请求支付宝的查询接口查询支付状态，这样可以减轻我们数据库服务器的压力。如果支付成功的话呢，会控制进行跳转。当然，时间久了二维码也会失效，会提示用户刷新
    为了将支付宝那边的支付记录的支付状态同步到我们的数据库中，我们向支付宝注册了一个回调地址，这个地址(控制器的requestMapping地址)的作用是如果二维码被支付成功，支付宝会请求我们这个地址，并且会携带支付成功的订单号，以及其他参数，获取到这些参数后就可以同步支付状态到我们的数据库中
    （支付安全） 还有一点就是微信支付和支付宝支付，首先要注册商家服务,然后再申请支付功能，为了保证安全，申请支付功能通过之后可以设置公钥和私钥，支付平台会利用私钥和公钥提供验签功能(采用RSA非对称加密算法)保证安全，防止恶意请求篡改参数
    (对账功能) 但是还有一个场景，就是支付成功之后，在进行回调的时候，网络超时了，这就会使订单状态无法更新，这个时候有两种解决方案：一是用户自己联系人工客服，提供订单号等信息，客服会去核对订单信息以及支付情况，人工客服手动修改订单状态；还有一种就是对账，定时的去微信或支付宝进行对账，写一个定时任务，每隔一段时间就去微信或支付宝去核对支付信息

### redis实现抢购秒杀功能
    要实现抢购秒杀功能，事先将需要加入抢购的商品id和开始抢购的时间以hash类型存放在redis cluster集群中，还需要本次抢购商品的库存，以及通过list类型存放的与库存数等量的商品序列号；
    当用户进入抢购页面时，需要向用户展示出商品的图片，商品名，抢购价格，库存数和剩余库存，以及开始抢购的时间等信息，当用户点击抢购的时候，首先在前台判断一下是否达到了开始抢购的时间，如果时间满足，就通过ajax将请求发送到抢购的controller，携带的参数是商品id，然后再次确认是否到了开始抢购的时间；
    我们是通过redis里面的list类型实现抢购的，如果有用户抢购成功，就将事先存好的商品序列号pop出来一个，一直到pop出空值，这就表示商品已经全部被抢完了；
    当然，很多抢购商品基本上都是每人只能抢一件，在此之前我们还要先判断一下该用户是否已经抢购成功一次了，因此需要将抢购成功的用户的id存入redis cluster集群中
### 分布式
####说一说你对分布式的理解：
    分布式就是一种分而治之的思想，用于解决互联网大并发的应用场景。
    对于传统的项目，比如ssm、ssh，所有的功能都耦合在一起，一起进行开发以及部署。优点：开发快捷，部署简单。缺点：所有的功能全部耦合在一起，不利于二次开发；在大并发场景下，单点功能会影响整个系统的稳定性。
    分布式架构，比如dubbo、spring cloud等；dubbo是面向rpc，spring cloud是面向http；dubbo的优势在于rpc的调用是通过局域网，不受网络带宽的影响，速度稍快；spring cloud的优势在于比dubbo多了统一的网关以及熔断路由的功能，spring cloud算是严格意义上的微服务，dubbo只是rpc的治理；现在互联网公司用dubbo(HSF、JSF)、spring cloud平分秋色，但是趋势是向spring cloud靠近；分布式架构可以解决由大并发导致的所有功能全部失效的问题。
    注意：每一个服务都使用自己独立的数据库服务：是指由controller等组成的供客户端调用的接口
### dubbo架构：
    dubbo是一个开源的分布式服务治理的rpc框架，它提供了服务的注册和发现机制，当服务提供者启动的时候会向注册中心写入自己的服务名以及服务器地址，服务消费者启动的时候，会向服务中心订阅某一服务，注册中心会将该服务对应的服务器地址推送给消费者，如果服务提供者有地址变更，注册中心会推送新的地址给服务消费者，然后服务消费者通过负载均衡算法，选择一个服务提供的url，进行RPC调用；dubbo的rpc协议默认是dubbo协议，dubbo协议的底层是通过基于netty的tcp长连接的NIO，NIO有三个核心组件：channel、selector、buffer，channel是多路复用的管道，selector是轮询器，buffer是数据缓冲区；dubbo支持多协议注册中心，我们在项目当中通常使用zookeeper充当注册中心；dubbo还提供了监控中心，监控服务的使用情况。
#### dubbo的网关：
    dubbo没有自己的统一网关，一般用nginx服务器来做dubbo的网关；nginx用来开发网关的配置文件，指定请求转发的策略以及转发给谁，配置文件当中得写死ip地址和端口号；但是对于dubbo架构，api层的机器如何平滑的添加tomcat？
    可以通过zookeeper集群来实现，当api层的机器启动之后，会向zookeeper集群写入自己的地址，在nginx服务器中写一个lua脚本，监听zookeeper集群当中记录的所有的tomcat的地址，一但有新机器添加或移除，nginx就通过lua脚本重新生成负载均衡的配置文件，直接热加载
    两个环境公用同一个注册中心，怎么能保证环境的服务消费者调用到的一定是环境服务提供者：给服务分组 group version版本号

