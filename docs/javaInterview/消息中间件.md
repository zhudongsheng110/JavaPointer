> 七、**消息中间件**
- [市面上常用的消息中间件的优缺点以及使用场景](#市面上常用的消息中间件的优缺点以及使用场景)
- [rabbitMQ](#rabbitmq)
    - [rabbitMQ的消息发布模式](#rabbitmq的消息发布模式)
    - [rabbitMQ如何保证消息不会丢失?](#rabbitmq如何保证消息不会丢失)
    - [如何保证mq当中消息的幂等性（不被重复消费）](#如何保证mq当中消息的幂等性不被重复消费)
    - [对于分布式环境的id生成？](#对于分布式环境的id生成)
    - [你们项目什么地方使用到了mq？](#你们项目什么地方使用到了mq)
____
### 市面上常用的消息中间件的优缺点以及使用场景
    kafka  高吞吐(百万级别的数据写入)、高可用(数据备份、zookeeper)  大数据平台日志收集
    RocketMQ  吞吐量(几十万级)    大型互联网公司  
    rabbitMQ   吞吐量(万级)、高并发    中小型互联网公司  提供了事务以及消息确认机制
    activeMq  吞吐量(万级)             小型或者非互联网公司  
### rabbitMQ
    MQ称为消息队列,用于服务之间同步调用解耦，实现数据的最终一致性
    它的常用API  Connection channel exchange topic routingKey等等
    rabbitMQ是使用erlang语言开发的，天然支持高并发，提供了消息的确认机制，保证了消息的可靠性。
#### rabbitMQ的消息发布模式
       basic  点对点
       exchange  发布订阅
#### rabbitMQ如何保证消息不会丢失?
    消息丢失很有可能在生产者、mq服务、消费者任意一个环节出现
    生产者可以使用channel事务机制、confirm机制，前者能保证消息传递的
    可靠性，但是吞吐量会下降，这时候可以使用confirm机制，mq收到消息之后
    会进行ack回调通知
     mq采用持久化对消息进行硬盘存储，可以保证mq异常关机之后，数据不会丢失
    消费者 关闭rabbitMQ提供的自动ACK消息确认机制，改为消费者处理完消息之后,
    手动ACK(基于tcp的ack事务包)

#### 如何保证mq当中消息的幂等性（不被重复消费）
    生产者在生产消息的时候做幂等控制(使用全局、流程唯一的id)
    举例:生产者使用订单id、用户id的时候，先判断该消息是否已经存储了（redis）,然后再
    发送到mq。
    消费者消费消息的时候，也是使用全局唯一的标识，先判断是否已经消费过了，
    可以借助redis或数据库(唯一索引)，来保证不被重复消费

#### 对于分布式环境的id生成？
    使用统一的id发号器来生成主键(根据业务维度设计主键、末位有序)

#### 你们项目什么地方使用到了mq？
    1.用户抢购秒杀成功之后，生成订单之后，我们将订单号存储到了rabbitMQ,
    (我们通过死信队列、死信交换器、普通队列)来实现延迟队列,如果限定的
    支付时间之内，用户没有付款，那么我们需要消费mq当中的消息，操作数据库
    设置订单为已过期、库存回滚、积分回滚、优惠券回滚。
    2.为了保证redis缓存和数据库的数据一致性，我们采用rabbitMQ进行解耦，
    mysql数据变更通过binlog日志会记录下来,我们通过生产者监听mysql的binlog
    日志,将要更新的数据写入到mq，另一端消费者消费数据，更新到缓存当中